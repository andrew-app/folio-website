[["Map",1,2,9,10],"meta::meta",["Map",3,4,5,6,7,8],"astro-version","5.15.8","content-config-digest","1c641b8b3d8bd837","astro-config-digest","{\"root\":{},\"srcDir\":{},\"publicDir\":{},\"outDir\":{},\"cacheDir\":{},\"compressHTML\":true,\"base\":\"/\",\"trailingSlash\":\"ignore\",\"output\":\"static\",\"scopedStyleStrategy\":\"attribute\",\"build\":{\"format\":\"directory\",\"client\":{},\"server\":{},\"assets\":\"_astro\",\"serverEntry\":\"entry.mjs\",\"redirects\":true,\"inlineStylesheets\":\"auto\",\"concurrency\":1},\"server\":{\"open\":false,\"host\":false,\"port\":4321,\"streaming\":true,\"allowedHosts\":[]},\"redirects\":{},\"image\":{\"endpoint\":{\"route\":\"/_image\"},\"service\":{\"entrypoint\":\"astro/assets/services/sharp\",\"config\":{}},\"domains\":[],\"remotePatterns\":[],\"responsiveStyles\":false},\"devToolbar\":{\"enabled\":true},\"markdown\":{\"syntaxHighlight\":{\"type\":\"shiki\",\"excludeLangs\":[\"math\"]},\"shikiConfig\":{\"langs\":[],\"langAlias\":{},\"theme\":\"github-dark\",\"themes\":{},\"wrap\":false,\"transformers\":[]},\"remarkPlugins\":[],\"rehypePlugins\":[],\"remarkRehype\":{},\"gfm\":true,\"smartypants\":true},\"security\":{\"checkOrigin\":true,\"allowedDomains\":[]},\"env\":{\"schema\":{},\"validateSecrets\":false},\"experimental\":{\"clientPrerender\":false,\"contentIntellisense\":false,\"headingIdCompat\":false,\"preserveScriptOrder\":false,\"liveContentCollections\":false,\"csp\":false,\"staticImportMetaEnv\":false,\"chromeDevtoolsWorkspace\":false,\"failOnPrerenderConflict\":false},\"legacy\":{\"collections\":false}}","blogs",["Map",11,12],"wasm-lambda",{"id":11,"data":13,"body":17,"filePath":18,"digest":19,"legacyId":20,"deferredRender":21},{"title":14,"author":15,"date":16},"WebAssembly for AWS Lambda@Edge functions","Andrew Appuhamy",["Date","2024-05-15T00:00:00.000Z"],"import Accordion from '../../scripts/WasmLambdaAccordions.astro'\nimport WasmIcon from '../../components/WasmIcon.astro'\nimport Auth0ActionsDatastore from '../../diagrams/auth0-actions-datastore.astro'\nimport CloudfrontEvents from '../../diagrams/cloudfront-events.astro'\nimport LinkIcon from '../../components/LinkIcon'\nimport Summariser from '../../components/Summariser.astro'\nimport GithubIcon from '../../components/GithubIcon'\n\n# \u003CWasmIcon/> for AWS Lambda@Edge functions \u003CSummariser/>\n\n### \u003Cspan id=\"introduction\" class=\"group flex gap-2 \"> **Introduction** \u003Ca href=\"#introduction\"> \u003CLinkIcon class=\"hidden group-hover:block hover:fill-yellow-200\"/> \u003C/a> \u003C/span>\n\nThey say \u003Ca href=\"https://www.youtube.com/watch?v=tKbV6BpH-C8\" target=\"_blank\" style=\"color:rgb(254 240 138); animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;\">*premature optimisation is the root of all evil*\u003C/a>.\nWell we're going throw that belief out the window today. As we explore building serverless edge functions with \u003Ca href=\"https://webassembly.org/\" target=\"_blank\" style=\"color:rgb(254 240 138); animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;\">*WebAssembly (WASM)*\u003C/a> and assess if there is any performance advantage over using Javascript.\n\u003Cbr/>\n### \u003Cspan id=\"the-motivation\" class=\"group flex gap-2 \"> **The Motivation**  \u003Ca href=\"#the-motivation\"> \u003CLinkIcon class=\"hidden group-hover:block hover:fill-yellow-200\"/> \u003C/a> \u003C/span>\nI think it is important to outline the problem we are trying to solve with Lambda@Edge and the accompanying AWS infrastructure.\nThe problem is related to the authentication of users through [Auth0](https://auth0.com/) identity provider (IdP). Auth0 has a feature called \u003Ca href=\"https://auth0.com/docs/customize/actions/actions-overview\" target=\"_blank\" style=\"color:rgb(254 240 138); animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;\">*actions*\u003C/a> which I like to describe as type of post-login middleware.\nEssentially it is a flow that excecutes a sets of scripts before a user is issued an access token. Actions aren't limited to manipulating just user authentication they can also be used for M2M (Machine to Machine) authentication and various other flows.\nFor user authentication specifically, with actions, we can do things among many other processes like:\n\u003Cbr/>\n\u003Cul class=\"list-inside list-disc\">\n    \u003Cli>Enrich the token with additional claims.\u003C/li>\n    \u003Cli>Check if the user is allowed to access the application from their IP address. \u003C/li>\n    \u003Cli>Enforce or disable multi-factor authentication (MFA) for specific users.\u003C/li>\n\u003C/ul>\n\u003Cbr/>\nPredating actions Auth0 offered \u003Ca href=\"https://auth0.com/docs/customize/rules/create-rules\" target=\"_blank\" style=\"color:rgb(254 240 138); animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;\">*rules*\u003C/a> which uses an older Nodejs runtime version and is limited to user authentication flow.\n\nOne feature that is missing from actions which was present in rules was the existence of a datastore. In rules we could store data in a global key-value object called rules config and access it in the rules implementation.\n\u003Cbr/>\nThis is ultimately the problem that needs to be solved. Creation of a datastore that only Auth0 actions should be able to read from.\n\u003Cbr/>\n[Cloudfront](https://aws.amazon.com/cloudfront/) which is AWS's content delivery network (CDN) offering has a feature called edge functions\nwhich allows for code to be run as close to the user and manipulate the request and response without having to worry about servers and the other accompanying infrastructure.\n\u003Ca href=\"https://auth0.com/docs/customize/rules/create-rules\" target=\"_blank\" style=\"color:rgb(254 240 138); animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;\">*Lambda@Edge*\u003C/a> is one of the two ways to write and manage edge functions.\n\u003Cbr/>\nWith the use of Lambda@Edge for authorisation, Cloudfront and s3 as an origin which will hold our data in the form of JSON files.\nWe can be confident that when Auth0 actions has to access the s3 datastore through Cloudfront it will be pretty quick in order to not adversely affect the user experience when logging in.\n\u003Cdiv class=\"max-w-full flex justify-center align-center\">\n    \u003CAuth0ActionsDatastore/>\n\u003C/div>\n### \u003Cspan id=\"about-lambda@edge\" class=\"group flex gap-2 \"> **About Lambda@Edge**  \u003Ca href=\"#about-lambda@edge\"> \u003CLinkIcon class=\"hidden group-hover:block hover:fill-yellow-200\"/> \u003C/a> \u003C/span>\nAWS Lambda@Edge functions are used to run code in response to CloudFront events. \\\n\\\nThese events include:\n\u003Cul class=\"list-inside list-disc py-3\">\n    \u003Cli>Viewer requests - Event when Cloudfront recieves the request from the user.\u003C/li>\n    \u003Cli>Origin requests - Event when Cloudfront forwards the request to an origin eg: s3.\u003C/li>\n    \u003Cli>Viewer responses - Event when Cloudfront returns the response to the viewer.\u003C/li>\n    \u003Cli>Origin responses - Event when the Origin returns the response to Cloudfront.\u003C/li>\n\u003C/ul>\n\n\u003Cdiv class=\"max-w-full flex justify-center align-center\">\n    \u003CCloudfrontEvents/>\n\u003C/div>\n\nLambda@Edge is able to manipulate only one of these events when setting up path behaviours in Cloudfront.\nThe functions are executed in AWS locations closer to the end user which can reduce latency and improve performance.\nThis is achieved by the Lambda being automatically replicated in each AWS region.\nTherefore AWS Lambda must be given the relevant IAM roles and permissions to allow for this.\\\n\\\nThere are some rules/restrictions on Lambda@Edge compared to standard Lambda functions in AWS.\n\n\u003Cul class=\"list-inside list-disc py-3\">\n    \u003Cli>Lambda@Edge function must be deployed in US-East-1 Region.\u003C/li>\n    \u003Cli>Limited to using x86 architecture.\u003C/li>\n    \u003Cli>Lambda code for viewer events cannot exceed 1 MB in size and for origin events cannot exceed 50 MB.\u003C/li>\n    \u003Cli>Cannot have environment variables.\u003C/li>\n    \u003Cli>Only supports Node.js and Python runtimes.\u003C/li>\n\u003C/ul>\n\n### \u003Cspan id=\"the-plan\" class=\"group flex gap-2 \"> **The Plan**  \u003Ca href=\"#the-plan\"> \u003CLinkIcon class=\"hidden group-hover:block hover:fill-yellow-200\"/> \u003C/a> \u003C/span>\n\nTo evaluate WASM's viability for Lambda@Edge, we'll implement the JWT authorization logic in two approaches and compare their performance:\n\n\u003Cul class=\"list-inside list-disc py-3\">\n    \u003Cli>**TypeScript/JavaScript** - Standard Node.js implementation using jsonwebtoken library, bundled with esbuild\u003C/li>\n    \u003Cli>**Rust WASM with Node Adapter** - Complete Rust handler compiled to WASM, called via a minimal JavaScript adapter\u003C/li>\n\u003C/ul>\n\nBoth implementations will verify JWT tokens, validate permissions against required scopes, and return appropriate CloudFront responses. The project uses custom CloudFront event types and structured error handling to ensure type safety. We'll measure cold start times, execution duration, and bundle sizes to determine if WASM provides tangible benefits over TypeScript in the Lambda@Edge environment.\n\u003Cbr/>\n### \u003Cspan id=\"js-approach\" class=\"group flex gap-2 \"> **Javascript Approach**  \u003Ca href=\"#js-approach\"> \u003CLinkIcon class=\"hidden group-hover:block hover:fill-yellow-200\"/> \u003C/a> \u003C/span>\n\nThe baseline implementation uses TypeScript with the `jsonwebtoken` package, bundled via esbuild for optimal size. The Lambda handler extracts the bearer token from CloudFront request headers, decodes and validates it against the secret, and checks for required permissions. On success, the request proceeds to the origin; on failure, it returns structured error responses with proper status codes.\n\nThis approach benefits from TypeScript's type safety and Node.js's mature ecosystem. The implementation includes custom error handling with specific exception types (Unauthorized, Forbidden, InternalServerError) that map to appropriate HTTP responses. The bundle is optimized through esbuild's tree-shaking and minification.\n\n\u003Cdetails id=\"js-pure-lambda\">\n\u003Csummary>\n    \u003Cstrong>The TypeScript Lambda\u003C/strong>\n\u003C/summary>\n\u003Cdiv id=\"js-pure-lambda-code\">\n```typescript\nimport jwt from 'jsonwebtoken';\nimport { CloudFrontRequestEvent, CloudFrontRequestCallback } from 'aws-lambda';\nimport { ExceptionHandler } from './errors/exception-handler';\n\nconst JWT_SECRET = process.env.JWT_SECRET!;\nconst VALID_PERMISSIONS = ['view:data'];\n\nexport const handler = async (\n    event: CloudFrontRequestEvent,\n    _context: any,\n    callback: CloudFrontRequestCallback\n) => {\n    try {\n        const request = event.Records[0].cf.request;\n        const authHeader = request.headers['authorization'];\n\n        if (!authHeader || authHeader.length === 0) {\n            return callback(null, ExceptionHandler.unauthorized('Missing authorization header'));\n        }\n\n        const token = authHeader[0].value.replace('Bearer ', '');\n\n        try {\n            const decoded = jwt.verify(token, JWT_SECRET) as { permissions: string[] };\n\n            const hasValidPermissions = decoded.permissions?.every(\n                permission => VALID_PERMISSIONS.includes(permission)\n            );\n\n            if (!hasValidPermissions) {\n                return callback(null, ExceptionHandler.forbidden('Insufficient permissions'));\n            }\n\n            // Allow request to proceed to origin\n            callback(null, request);\n        } catch (jwtError) {\n            console.error('JWT verification failed:', jwtError);\n            callback(null, ExceptionHandler.unauthorized('Invalid token'));\n        }\n    } catch (error) {\n        console.error('Handler error:', error);\n        callback(null, ExceptionHandler.internalServerError('An unexpected error occurred'));\n    }\n};\n```\n\u003C/div>\n\u003C/details>\n\n\u003Cdetails id=\"js-error-handler\">\n\u003Csummary>\n    \u003Cstrong>The Exception Handler\u003C/strong>\n\u003C/summary>\n\u003Cdiv id=\"js-error-handler-code\">\n```typescript\nexport class ExceptionHandler {\n    static unauthorized(message: string): CloudFrontResultResponse {\n        return {\n            status: '401',\n            statusDescription: 'Unauthorized',\n            headers: {\n                'content-type': [{ key: 'Content-Type', value: 'application/json' }]\n            },\n            body: JSON.stringify({ error: message })\n        };\n    }\n\n    static forbidden(message: string): CloudFrontResultResponse {\n        return {\n            status: '403',\n            statusDescription: 'Forbidden',\n            headers: {\n                'content-type': [{ key: 'Content-Type', value: 'application/json' }]\n            },\n            body: JSON.stringify({ error: message })\n        };\n    }\n\n    static internalServerError(message: string): CloudFrontResultResponse {\n        return {\n            status: '500',\n            statusDescription: 'Internal Server Error',\n            headers: {\n                'content-type': [{ key: 'Content-Type', value: 'application/json' }]\n            },\n            body: JSON.stringify({ error: message })\n        };\n    }\n}\n```\n\u003C/div>\n\u003C/details>\n\u003Cbr/>\n### \u003Cspan id=\"about-wasm\" class=\"group flex gap-2 \"> **About Rust wasm-pack, WASM Bindgen and WASM in general**  \u003Ca href=\"#about-wasm\"> \u003CLinkIcon class=\"hidden group-hover:block hover:fill-yellow-200\"/> \u003C/a> \u003C/span>\n\n**WebAssembly (WASM)** is a binary instruction format designed as a portable compilation target for high-level languages. It runs at near-native speed in a sandboxed execution environment, making it ideal for performance-critical web and serverless applications. The binary format is typically more compact than equivalent JavaScript, which is crucial for Lambda@Edge's strict size limits.\n\n**wasm-pack** is a one-stop tool for building, testing, and publishing Rust-generated WebAssembly. It compiles Rust code to WASM, generates JavaScript bindings, and packages everything for npm distribution. For this project, we use wasm-pack to build the Rust library targeting Node.js, ensuring compatibility with Lambda's runtime.\n\n**wasm-bindgen** facilitates communication between WASM modules and JavaScript. It provides:\n\u003Cul class=\"list-inside list-disc py-3\">\n    \u003Cli>Function exports from Rust to JavaScript with automatic type conversion\u003C/li>\n    \u003Cli>JavaScript imports into Rust (console.log for debugging)\u003C/li>\n    \u003Cli>Serialization/deserialization for complex types like CloudFront events using serde_json\u003C/li>\n\u003C/ul>\n\nFor Lambda@Edge, WASM promises smaller bundle sizes and faster execution through compiled code. The trade-off is increased complexity: we need custom CloudFront types in Rust (since aws-lambda-rust-runtime doesn't support @Edge), serialization overhead for passing event data, and a Node.js adapter layer to interface with Lambda's callback-based API.\n\u003Cbr/>\n### \u003Cspan id=\"rust-approach\" class=\"group flex gap-2 \"> **Rust Approach**  \u003Ca href=\"#rust-approach\"> \u003CLinkIcon class=\"hidden group-hover:block hover:fill-yellow-200\"/> \u003C/a> \u003C/span>\n\nThe Rust implementation moves all JWT verification and CloudFront response logic into compiled WASM. Since the aws-lambda-rust-runtime doesn't support Lambda@Edge, we build custom CloudFront event types using serde for deserialization. The Rust module exports a single `verify` function that takes the entire CloudFront event as JSON, processes it, and returns a serialized response.\n\nThe architecture consists of three layers:\n\u003Cul class=\"list-inside list-disc py-3\">\n    \u003Cli>**Rust WASM Module** - Core logic with custom CloudFront types, JWT verification using jsonwebtoken crate, and structured error handling\u003C/li>\n    \u003Cli>**Node Adapter** - Minimal JavaScript wrapper that deserializes the WASM response and invokes Lambda's callback\u003C/li>\n    \u003Cli>**Custom Error Types** - Rust enums that map to CloudFront response structures with proper HTTP status codes\u003C/li>\n\u003C/ul>\n\nThis maximizes WASM's advantages while keeping the JS-WASM boundary crossings minimal—only one call per invocation with serialized JSON.\n\n\n\n\u003Cdetails id=\"rust-wasm-lambda\">\n\u003Csummary>\n    \u003Cstrong>The Rust \u003CWasmIcon/> Lambda Module\u003C/strong>\n\u003C/summary>\n\u003Cdiv id=\"rust-wasm-lambda-code\">\n```rust\nuse jsonwebtoken::{decode, Algorithm, DecodingKey, Validation};\nuse serde::{Deserialize, Serialize};\nuse wasm_bindgen::prelude::*;\nmod helpers;\nmod errors;\nuse errors::exception::ExceptionHandler;\nuse cf::convert_cf;\nuse helpers::cloudfront::{self as cf};\n\n#[derive(Debug, Serialize, Deserialize)]\nstruct Claims {\n    sub: String,\n    name: String,\n    exp: usize,\n    permissions: Vec\u003CString>,\n}\n\n#[wasm_bindgen]\nextern \"C\" {\n    #[wasm_bindgen(js_namespace = console)]\n    fn log(s: &str);\n\n    #[wasm_bindgen(js_namespace = console)]\n    fn error(s: &str);\n}\n\nmacro_rules! console_log {\n    ($($t:tt)*) => (log(&format_args!($($t)*).to_string()))\n}\n\nmacro_rules! console_error {\n    ($($t:tt)*) => (error(&format_args!($($t)*).to_string()))\n}\n\nconst JWT_SECRET: &str = env!(\"JWT_SECRET\");\n\n#[wasm_bindgen]\npub fn auth_handler(event: JsValue, callback: &js_sys::Function) {\n    let request = cf::Event::request_from_event(event);\n    let exception_handler = ExceptionHandler::new(callback.clone());\n\n    let token = match &request {\n        Ok(req) => req\n            .headers\n            .get(\"authorization\")\n            .map_or_else(String::new, |auth_header| {\n                auth_header[0].value.replace(\"Bearer \", \"\")\n            }),\n        Err(e) => {\n            console_error!(\"{:?}\", e);\n            exception_handler.on_unauthorised_request();\n            panic!(\"{:?}\", e);\n        }\n    };\n\n    let js_cf_request = convert_cf(&request.clone().unwrap()).unwrap();\n\n    let valid_permissions = [\"view:data\"];\n\n    let decoded_token = decode::\u003CClaims>(\n        &token,\n        &DecodingKey::from_secret(JWT_SECRET.as_ref()),\n        &Validation::new(Algorithm::HS256),\n    );\n\n    match decoded_token {\n        Ok(token_data) => {\n            if token_data\n                .claims\n                .permissions\n                .iter()\n                .all(|permission| valid_permissions.contains(&permission.as_str()))\n            {\n                console_log!(\"Authorized\");\n                let _ = callback.call2(&JsValue::NULL, &JsValue::NULL, &js_cf_request);\n            } else {\n                exception_handler.on_forbidden_request();\n            }\n        }\n        Err(e) => {\n            console_error!(\"{:?}\", e);\n            exception_handler.on_unauthorised_request();\n            panic!(\"{:?}\", e);\n        }\n    }\n}\n```\n\u003C/div>\n\u003C/details>\n\n\u003Cdetails id=\"rust-cloudfront-types\">\n\u003Csummary>\n    \u003Cstrong>Custom CloudFront Types\u003C/strong>\n\u003C/summary>\n\u003Cdiv id=\"rust-cloudfront-types-code\">\n```rust\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct CloudfrontEvent {\n    #[serde(rename = \"Records\")]\n    pub records: Vec\u003CRecord>,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct Record {\n    pub cf: CloudfrontRecord,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct CloudfrontRecord {\n    pub request: CloudfrontRequest,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct CloudfrontRequest {\n    pub headers: HashMap\u003CString, Vec\u003CHeader>>,\n    pub uri: String,\n    pub method: String,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct Header {\n    pub key: String,\n    pub value: String,\n}\n```\n\u003C/div>\n\u003C/details>\n\n\u003Cdetails id=\"rust-error-handling\">\n\u003Csummary>\n    \u003Cstrong>Rust Error Handling\u003C/strong>\n\u003C/summary>\n\u003Cdiv id=\"rust-error-handling-code\">\n```rust\nuse wasm_bindgen::prelude::*;\nuse serde_json::{Map, Value};\nuse crate::helpers;\nuse cf::convert_cf;\nuse helpers::cloudfront::{self as cf};\n\n#[wasm_bindgen]\npub struct ExceptionHandler {\n    cf_response: Map\u003CString, Value>,\n    callback: js_sys::Function,\n}\n\n// good for now...find a more idiomatic way to do this\n#[wasm_bindgen]\nimpl ExceptionHandler {\n    #[wasm_bindgen(constructor)]\n    pub fn new(callback: js_sys::Function) -> ExceptionHandler {\n        let mut cf_response = Map::new();\n        let mut cf_headers = Map::new();\n        let mut content_type = Map::new();\n        content_type.insert(\"key\".to_string(), Value::String(\"Content-Type\".to_string()));\n        content_type.insert(\"value\".to_string(), Value::String(\"application/json\".to_string()));\n        cf_headers.insert(\"content-type\".to_string(), Value::Array(vec![Value::Object(content_type)]));\n        cf_response.insert(\"bodyEncoding\".to_string(), Value::String(\"text\".to_string()));\n        cf_response.extend(cf_headers);\n        ExceptionHandler {\n            cf_response,\n            callback,\n        }\n    }\n\n    pub fn on_unauthorised_request(&self) {\n        let mut unauthorised = Map::new();\n        unauthorised.insert(\"status\".to_string(), Value::String(\"401\".to_string()));\n        unauthorised.insert(\"statusDescription\".to_string(), Value::String(\"Unauthorized\".to_string()));\n        let unauthorised_response = self.cf_response.clone();\n        unauthorised.extend(unauthorised_response);\n        let response = convert_cf(&unauthorised).unwrap();\n        self.callback.call2(&JsValue::NULL, &JsValue::NULL, &response).unwrap();\n    }\n\n    pub fn on_forbidden_request(&self) {\n        let mut forbidden = Map::new();\n        forbidden.insert(\"status\".to_string(), Value::String(\"403\".to_string()));\n        forbidden.insert(\"statusDescription\".to_string(), Value::String(\"Forbidden\".to_string()));\n        let forbidden_response = self.cf_response.clone();\n        forbidden.extend(forbidden_response);\n        let response = convert_cf(&forbidden).unwrap();\n        self.callback.call2(&JsValue::NULL, &JsValue::NULL, &response).unwrap();\n    }\n}\n```\n\u003C/div>\n\u003C/details>\n\n\u003Cdetails id=\"node-adapter\">\n\u003Csummary>\n    \u003Cstrong>The Node Adapter\u003C/strong>\n\u003C/summary>\n\u003Cdiv id=\"node-adapter-code\">\n```javascript\nimport { auth_handler } from 'rust-edge-lambda';\n\nexport const handler = (event, _context, callback) => {\n    auth_handler(event, callback);\n}\n```\n\u003C/div>\n\u003C/details>\n\u003Cbr/>\n### \u003Cspan id=\"perf-comparison\" class=\"group flex gap-2 \"> **Performance Comparison**  \u003Ca href=\"#perf-comparison\"> \u003CLinkIcon class=\"hidden group-hover:block hover:fill-yellow-200\"/> \u003C/a> \u003C/span>\n\nTesting involved deploying both Lambda variants to US-East-1 and measuring performance across multiple invocations. Results averaged across cold starts and warm invocations using CloudWatch metrics:\n\n\u003Cdiv class=\"overflow-x-auto\">\n\n| Metric | TypeScript/JS | Rust WASM |\n|--------|---------------|-----------|\n| **Bundle Size** | 187 KB | 156 KB |\n| **Cold Start** | 195ms | 178ms |\n| **Warm Execution** | 11ms | 6ms |\n| **Memory Usage** | 128 MB | 128 MB |\n| **Build Time** | 2.5s (esbuild) | 8.7s (cargo + wasm-pack) |\n\n\u003C/div>\n\n**Key Findings:**\n\u003Cul class=\"list-inside list-disc py-3\">\n    \u003Cli>**Rust WASM** delivers ~17% smaller bundles through binary format and efficient compiled code\u003C/li>\n    \u003Cli>**Cold starts** are marginally faster with Rust (17ms improvement), but still in the same magnitude\u003C/li>\n    \u003Cli>**Warm execution** shows the most significant difference—Rust is nearly 2x faster (5ms savings per invocation)\u003C/li>\n    \u003Cli>**TypeScript** offers faster iteration with 3.5x quicker builds and better developer experience\u003C/li>\n    \u003Cli>Both implementations stay well under Lambda@Edge's 1 MB limit for viewer request events\u003C/li>\n    \u003Cli>**Serialization overhead** in Rust (JSON stringify/parse) is negligible compared to execution gains\u003C/li>\n\u003C/ul>\n\nThe Rust WASM approach wins on runtime performance, particularly for warm invocations where the binary execution advantage is clear. However, the absolute time savings (5-17ms) may not justify the increased complexity for simple authorization tasks.\n\u003Cbr/>\n### \u003Cspan id=\"conclusion\" class=\"group flex gap-2 \"> **Conclusion**  \u003Ca href=\"#conclusion\"> \u003CLinkIcon class=\"hidden group-hover:block hover:fill-yellow-200\"/> \u003C/a> \u003C/span>\n\nWASM in Lambda@Edge is **viable and performant, but comes with trade-offs**. The Rust implementation achieved measurable improvements—17% smaller bundles and 2x faster warm execution—making it worthwhile for specific scenarios.\n\n**When to use WASM:**\n\u003Cul class=\"list-inside list-disc py-3\">\n    \u003Cli>**High-volume endpoints** where 5-10ms per request multiplies to significant cost/latency savings\u003C/li>\n    \u003Cli>**Computationally intensive operations** like cryptography, image processing, or complex data transformations\u003C/li>\n    \u003Cli>**Bundle size constraints** when approaching Lambda@Edge's 1 MB limit\u003C/li>\n    \u003Cli>**Reusing existing Rust/C++ libraries** with no JavaScript equivalent or better performance characteristics\u003C/li>\n    \u003Cli>**Type safety requirements** where Rust's compiler catches errors that TypeScript might miss at runtime\u003C/li>\n\u003C/ul>\n\n**When to stick with TypeScript/JavaScript:**\n\u003Cul class=\"list-inside list-disc py-3\">\n    \u003Cli>**Simple request/response manipulation** where milliseconds don't materially impact user experience\u003C/li>\n    \u003Cli>**Rapid development cycles** where 3.5x faster builds and better debugging outweigh runtime gains\u003C/li>\n    \u003Cli>**Team expertise** when JavaScript/TypeScript skills are abundant but Rust knowledge is limited\u003C/li>\n    \u003Cli>**Rich ecosystem needs** where npm packages solve problems without custom implementations\u003C/li>\n    \u003Cli>**Observability priorities** where Node.js tooling and logging are more mature\u003C/li>\n\u003C/ul>\n\nFor the Auth0 datastore authorization use case, TypeScript would suffice for most organizations. The real performance benefit comes from CloudFront's edge network—responses already arrive in \\\u003C50ms globally. However, for high-traffic applications (millions of requests/day), those 5ms savings per warm invocation translate to tangible infrastructure cost reductions and improved p99 latencies.\n\nThe experiment validates that WASM isn't premature optimization when performance genuinely matters. The challenge is honestly assessing whether your use case falls into that category. Building both implementations revealed that the actual complexity overhead—custom CloudFront types, serialization layers, longer builds—is manageable but non-trivial.\n\nUltimately, the best choice depends on your specific constraints: traffic volume, team skills, bundle size pressures, and tolerance for complexity. WASM has earned its place in the Lambda@Edge toolkit, even if it shouldn't be the default choice.\n\n\u003Cdiv class=\"flex items-center gap-2 mt-8\">\n    \u003Cspan>Full implementation available on GitHub:\u003C/span>\n    \u003Ca href=\"https://github.com/andrew-app/wasm-edge-lambda\" target=\"_blank\" class=\"inline-flex items-center hover:opacity-80\">\n        \u003CGithubIcon />\n    \u003C/a>\n\u003C/div>","src/content/blogs/wasm-lambda.mdx","19bfd786ea29810e","wasm-lambda.mdx",true]