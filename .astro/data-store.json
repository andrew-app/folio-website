[["Map",1,2,9,10],"meta::meta",["Map",3,4,5,6,7,8],"astro-version","5.15.8","content-config-digest","209b6bda1a579412","astro-config-digest","{\"root\":{},\"srcDir\":{},\"publicDir\":{},\"outDir\":{},\"cacheDir\":{},\"compressHTML\":true,\"base\":\"/\",\"trailingSlash\":\"ignore\",\"output\":\"static\",\"scopedStyleStrategy\":\"attribute\",\"build\":{\"format\":\"directory\",\"client\":{},\"server\":{},\"assets\":\"_astro\",\"serverEntry\":\"entry.mjs\",\"redirects\":true,\"inlineStylesheets\":\"auto\",\"concurrency\":1},\"server\":{\"open\":false,\"host\":false,\"port\":4321,\"streaming\":true,\"allowedHosts\":[]},\"redirects\":{},\"image\":{\"endpoint\":{\"route\":\"/_image\"},\"service\":{\"entrypoint\":\"astro/assets/services/sharp\",\"config\":{}},\"domains\":[],\"remotePatterns\":[],\"responsiveStyles\":false},\"devToolbar\":{\"enabled\":true},\"markdown\":{\"syntaxHighlight\":{\"type\":\"shiki\",\"excludeLangs\":[\"math\"]},\"shikiConfig\":{\"langs\":[],\"langAlias\":{},\"theme\":\"github-dark\",\"themes\":{},\"wrap\":false,\"transformers\":[]},\"remarkPlugins\":[],\"rehypePlugins\":[],\"remarkRehype\":{},\"gfm\":true,\"smartypants\":true},\"security\":{\"checkOrigin\":true,\"allowedDomains\":[]},\"env\":{\"schema\":{},\"validateSecrets\":false},\"experimental\":{\"clientPrerender\":false,\"contentIntellisense\":false,\"headingIdCompat\":false,\"preserveScriptOrder\":false,\"liveContentCollections\":false,\"csp\":false,\"staticImportMetaEnv\":false,\"chromeDevtoolsWorkspace\":false,\"failOnPrerenderConflict\":false},\"legacy\":{\"collections\":false}}","blogs",["Map",11,12],"wasm-lambda",{"id":11,"data":13,"body":17,"filePath":18,"digest":19,"legacyId":20,"deferredRender":21},{"title":14,"author":15,"date":16},"WebAssembly for AWS Lambda@Edge functions","Andrew Appuhamy",["Date","2024-05-15T00:00:00.000Z"],"import Accordion from '../../scripts/WasmLambdaAccordions.astro'\nimport WasmIcon from '../../components/WasmIcon.astro'\nimport Auth0ActionsDatastore from '../../diagrams/auth0-actions-datastore.astro'\nimport CloudfrontEvents from '../../diagrams/cloudfront-events.astro'\nimport LinkIcon from '../../components/LinkIcon'\nimport Summariser from '../../components/Summariser.astro'\n\n# \u003CWasmIcon/> for AWS Lambda@Edge functions \u003CSummariser/>\n\n### \u003Cspan id=\"introduction\" class=\"group flex gap-2 \"> **Introduction** \u003Ca href=\"#introduction\"> \u003CLinkIcon class=\"hidden group-hover:block hover:fill-yellow-200\"/> \u003C/a> \u003C/span>\n\nThey say \u003Ca href=\"https://www.youtube.com/watch?v=tKbV6BpH-C8\" target=\"_blank\" style=\"color:rgb(254 240 138); animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;\">*premature optimisation is the root of all evil*\u003C/a>. \nWell we're going throw that belief out the window today. As we explore building serverless edge functions with \u003Ca href=\"https://webassembly.org/\" target=\"_blank\" style=\"color:rgb(254 240 138); animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;\">*WebAssembly (WASM)*\u003C/a> and assess if there is any performance advantage over using Javascript.\n\n### \u003Cspan id=\"the-motivation\" class=\"group flex gap-2 \"> **The Motivation**  \u003Ca href=\"#the-motivation\"> \u003CLinkIcon class=\"hidden group-hover:block hover:fill-yellow-200\"/> \u003C/a> \u003C/span>\nI think it is important to outline the problem we are trying to solve with Lambda@Edge and the accompanying AWS infrastructure.\nThe problem is related to the authentication of users through [Auth0](https://auth0.com/) identity provider (IdP). Auth0 has a feature called \u003Ca href=\"https://auth0.com/docs/customize/actions/actions-overview\" target=\"_blank\" style=\"color:rgb(254 240 138); animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;\">*actions*\u003C/a> which I like to describe as type of post-login middleware. \nEssentially it is a flow that excecutes a sets of scripts before a user is issued an access token. Actions aren't limited to manipulating just user authentication they can also be used for M2M (Machine to Machine) authentication and various other flows.\nFor user authentication specifically, with actions, we can do things among many other processes like:\n\u003Cbr/>\n\u003Cul class=\"list-inside list-disc\">\n    \u003Cli>Enrich the token with additional claims.\u003C/li>\n    \u003Cli>Check if the user is allowed to access the application from their IP address. \u003C/li>\n    \u003Cli>Enforce or disable multi-factor authentication (MFA) for specific users.\u003C/li>\n\u003C/ul>\n\u003Cbr/>\nPredating actions Auth0 offered \u003Ca href=\"https://auth0.com/docs/customize/rules/create-rules\" target=\"_blank\" style=\"color:rgb(254 240 138); animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;\">*rules*\u003C/a> which uses an older Nodejs runtime version and is limited to user authentication flow.\n\nOne feature that is missing from actions which was present in rules was the existence of a datastore. In rules we could store data in a global key-value object called rules config and access it in the rules implementation.\n\u003Cbr/>\nThis is ultimately the problem that needs to be solved. Creation of a datastore that only Auth0 actions should be able to read from.\n\u003Cbr/>\n[Cloudfront](https://aws.amazon.com/cloudfront/) which is AWS's content delivery network (CDN) offering has a feature called edge functions\nwhich allows for code to be run as close to the user and manipulate the request and response without having to worry about servers and the other accompanying infrastructure.\n\u003Ca href=\"https://auth0.com/docs/customize/rules/create-rules\" target=\"_blank\" style=\"color:rgb(254 240 138); animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;\">*Lambda@Edge*\u003C/a> is one of the two ways to write and manage edge functions.\n\u003Cbr/>\nWith the use of Lambda@Edge for authorisation, Cloudfront and s3 as an origin which will hold our data in the form of JSON files. \nWe can be confident that when Auth0 actions has to access the s3 datastore through Cloudfront it will be pretty quick in order to not adversely affect the user experience when logging in.\n\u003Cdiv class=\"max-w-full flex justify-center align-center\">\n    \u003CAuth0ActionsDatastore/>\n\u003C/div>\n### \u003Cspan id=\"about-lambda@edge\" class=\"group flex gap-2 \"> **About Lambda@Edge**  \u003Ca href=\"#about-lambda@edge\"> \u003CLinkIcon class=\"hidden group-hover:block hover:fill-yellow-200\"/> \u003C/a> \u003C/span>\nAWS Lambda@Edge functions are used to run code in response to CloudFront events. \\\n\\\nThese events include:\n\u003Cul class=\"list-inside list-disc py-3\">\n    \u003Cli>Viewer requests - Event when Cloudfront recieves the request from the user.\u003C/li>\n    \u003Cli>Origin requests - Event when Cloudfront forwards the request to an origin eg: s3.\u003C/li>\n    \u003Cli>Viewer responses - Event when Cloudfront returns the response to the viewer.\u003C/li>\n    \u003Cli>Origin responses - Event when the Origin returns the response to Cloudfront.\u003C/li>\n\u003C/ul>\n\n\u003Cdiv class=\"max-w-full flex justify-center align-center\">\n    \u003CCloudfrontEvents/>\n\u003C/div>\n\nLambda@Edge is able to manipulate only one of these events when setting up path behaviours in Cloudfront.\nThe functions are executed in AWS locations closer to the end user which can reduce latency and improve performance. \nThis is achieved by the Lambda being automatically replicated in each AWS region. \nTherefore AWS Lambda must be given the relevant IAM roles and permissions to allow for this.\\\n\\\nThere are some rules/restrictions on Lambda@Edge compared to standard Lambda functions in AWS.\n\n\u003Cul class=\"list-inside list-disc py-3\">\n    \u003Cli>Lambda@Edge function must be deployed in US-East-1 Region.\u003C/li>\n    \u003Cli>Limited to using x86 architecture.\u003C/li>\n    \u003Cli>Lambda code for viewer events cannot exceed 1 MB in size and for origin events cannot exceed 50 MB.\u003C/li>\n    \u003Cli>Cannot have environment variables.\u003C/li>\n    \u003Cli>Only supports Node.js and Python runtimes.\u003C/li>\n\u003C/ul>\n\n### \u003Cspan id=\"the-plan\" class=\"group flex gap-2 \"> **The Plan**  \u003Ca href=\"#the-plan\"> \u003CLinkIcon class=\"hidden group-hover:block hover:fill-yellow-200\"/> \u003C/a> \u003C/span>\n\n### \u003Cspan id=\"js-approach\" class=\"group flex gap-2 \"> **Javascript Approach**  \u003Ca href=\"#js-approach\"> \u003CLinkIcon class=\"hidden group-hover:block hover:fill-yellow-200\"/> \u003C/a> \u003C/span>\n\n### \u003Cspan id=\"about-wasm\" class=\"group flex gap-2 \"> **About Rust wasm-pack, WASM Bindgen and WASM in general**  \u003Ca href=\"#about-wasm\"> \u003CLinkIcon class=\"hidden group-hover:block hover:fill-yellow-200\"/> \u003C/a> \u003C/span>\n\n### \u003Cspan id=\"hybrid-approach\" class=\"group flex gap-2 \"> **\"Hybrid\" Approach**  \u003Ca href=\"#hybrid-approach\"> \u003CLinkIcon class=\"hidden group-hover:block hover:fill-yellow-200\"/> \u003C/a> \u003C/span>\n\nInitial usage of the WASM module included some Javascript defined logic in particular the response when verifying the JWT and getting said JWT from the request header.\n\n\u003Cdetails id=\"wasm-hybrid-lambda\">\n    \u003Csummary>\n        \u003Cstrong>The Rust \u003CWasmIcon/> Module for \"Hybrid\" Lambda\u003C/strong>\n    \u003C/summary>\n\u003Cdiv id=\"wasm-hybrid-lambda-code\">\n```rust\n#[derive(Debug)]\npub enum Status {\n    Ok,\n    Unauthorized,\n    Forbidden,\n}\n\nimpl fmt::Display for Status {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match *self {\n            Status::Ok => write!(f, \"200\"),\n            Status::Unauthorized => write!(f, \"401\"),\n            Status::Forbidden => write!(f, \"403\"),\n        }\n    }\n}\n\nconst JWT_SECRET: &'static str = env!(\"JWT_SECRET\");\n\n#[wasm_bindgen]\npub fn verify(token: &str) -> String {\n    \n    let decoded_token = decode::\u003CClaims>(&token, &DecodingKey::from_secret(JWT_SECRET.as_ref()), &Validation::new(Algorithm::HS256));\n    let valid_permissions = vec![\"view:data\"];\n    match decoded_token {\n        Ok(token_data) => {\n            console_log!(\"{:?}\", token_data.claims);\n            if token_data.claims.permissions.iter().all(|permission| valid_permissions.contains(&permission.as_str())) {\n                return Status::Ok.to_string();\n            } else {\n                return Status::Forbidden.to_string();\n            }\n        },\n        Err(e) => {\n            console_log!(\"{}\",e);\n            return Status::Unauthorized.to_string();\n        }\n    }\n}\n```\n\u003C/div>\n\u003C/details>\n\n\u003Cdetails id=\"js-hybrid-lambda\">\n\u003Csummary>\n    \u003Cstrong>The \"Hybrid\" Lambda\u003C/strong>\n\u003C/summary>\n\u003Cdiv id=\"js-hybrid-lambda-code\">\n```javascript\nimport { verify } from 'rust-edge-lambda';\n\nexport const handler = async (event, _context, callback) => {\n    let authToken = '';\n    const request = event.Records[0].cf.request;\n\n    if (request.headers['authorization'])\n        authToken = request.headers['authorization'][0].value.replace(\"Bearer \", \"\")\n\n    try {\n        const verifyTokenResponse = verify(authToken);\n        switch (verifyTokenResponse) {\n            case '401':\n                response.status = '401';\n                response.statusDescription = 'Unauthorized';\n                response.body = JSON.stringify({ error: 'Invalid token' });\n                break;\n            case '403':\n                response.status = '403';\n                response.statusDescription = 'Forbidden';\n                break;\n            case '200':\n                callback(null, request);\n            default:\n                break;\n        }\n    }\n\n    catch(error) {\n        console.error(error);\n        response.status = '401';\n        response.statusDescription = 'Unauthorized';\n        response.body = JSON.stringify({ error: 'Invalid token' });\n    }\n\n    callback(null, response);\n}\n```\n\u003C/div>\n\u003C/details>\n\n### \u003Cspan id=\"rust-approach\" class=\"group flex gap-2 \"> **Rust Approach**  \u003Ca href=\"#rust-approach\"> \u003CLinkIcon class=\"hidden group-hover:block hover:fill-yellow-200\"/> \u003C/a> \u003C/span>\n\n### \u003Cspan id=\"perf-comparison\" class=\"group flex gap-2 \"> **Performance Comparison**  \u003Ca href=\"#perf-comparison\"> \u003CLinkIcon class=\"hidden group-hover:block hover:fill-yellow-200\"/> \u003C/a> \u003C/span>\n\n### \u003Cspan id=\"conclusion\" class=\"group flex gap-2 \"> **Conclusion**  \u003Ca href=\"#conclusion\"> \u003CLinkIcon class=\"hidden group-hover:block hover:fill-yellow-200\"/> \u003C/a> \u003C/span>","src/content/blogs/wasm-lambda.mdx","72817e949a58eca6","wasm-lambda.mdx",true]